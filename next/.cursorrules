# Development Guidelines

This project follows Next.js 15's standard best practices and conventions.

## Core Principles

1. **App Router & Server Components**

   - Use the App Router by default
   - Leverage Server Components for improved performance
   - Client Components only when necessary (use 'use client' directive)

2. **Data Fetching**

   - Use Server Components for data fetching
   - Implement Route Handlers for API endpoints
   - Utilize Next.js caching and revalidation patterns

3. **Routing & Layouts**

   - Follow Next.js file-system based routing
   - Use layout.tsx for shared UI
   - Implement loading.tsx for Suspense boundaries
   - Handle errors with error.tsx

4. **Forms & Mutations**

   - Use Server Actions for form submissions
   - Implement proper error handling and validation
   - Follow progressive enhancement principles

5. **Static & Dynamic Rendering**

   - Default to static rendering where possible
   - Use dynamic rendering when needed
   - Implement proper caching strategies

6. **Authentication**

   - Use Next.js middleware for route protection
   - Follow OAuth/session best practices
   - Implement proper CSRF protection

7. **Performance**

   - Use Next.js Image component
   - Implement proper loading states
   - Use streaming and Suspense
   - Follow recommended metadata patterns

8. **TypeScript**

   - Use TypeScript for type safety
   - Follow Next.js TypeScript conventions
   - Leverage built-in type definitions

9. **Styling**

   - Use CSS Modules or Tailwind CSS
   - Follow Next.js styling recommendations
   - Implement responsive design patterns

10. **Testing**
    - Use Next.js testing utilities
    - Follow React Testing Library practices
    - Implement E2E tests with Playwright

Remember: Follow the [Next.js documentation](https://nextjs.org/docs) for the most up-to-date best practices and patterns.

## Code Standards

1. **TypeScript Strictness**

   - Strict mode is mandatory
   - All components, functions, and variables must be explicitly typed
   - No use of `any` or `as` without documented justification
   - Use Prisma's generated types instead of custom interfaces

2. **Component Structure**

   - Place shared components in `/components` with appropriate subdirectories
   - Place page-specific components in `_components` folder adjacent to their page/layout
   - Follow atomic design principles (atoms, molecules, organisms)
   - One component per file
   - Use named exports: `export function ComponentName()`
   - Place page/component-specific Server Actions in `_actions` folder adjacent to the component/page
   - Co-locate related actions and components to maintain clear dependencies
   - Example structure:
     ```
     app/
       products/
         _actions/
           create-product.ts
           update-product.ts
         _components/
           ProductGrid.tsx
           ProductFilters.tsx
         page.tsx
         ProductForm.tsx
     ```

3. **State Management**

   - Cart state must use global store (Zustand preferred)
   - Server state must use React Query or similar caching solution
   - No prop drilling beyond 2 levels - use context or state management

4. **API Access**

   - All routes and endpoints are public
   - No authentication required for API access
   - Implement rate limiting for API protection
   - Consider caching strategies for optimal performance

5. **Server-Side Operations**

   - Use Server Actions for form submissions and mutations
   - Use Route Handlers (API routes) when needed for:
     - RESTful API endpoints
     - Complex API requirements
     - External API integrations
     - WebSocket connections
   - Implement proper error handling
   - Follow security best practices for data validation

6. **API Patterns**

   - Prefer Server Actions over API routes for internal operations
   - Server Actions should be co-located with their components in `_actions` folders
   - Use Route Handlers (API routes) only for:
     - External integrations
     - Webhook endpoints
     - Public APIs
     - Real-time functionality (WebSockets)
   - Server Actions must follow these patterns:

     ```typescript:example
     'use server'

     import { revalidatePath } from 'next/cache'
     import { redirect } from 'next/navigation'

     export async function exampleAction(formData: FormData) {
       // 1. Type and validate inputs
       // 2. Process action
       // 3. Revalidate affected paths
       // 4. Return or redirect
     }
     ```

   - Key Server Action principles:
     - Always use strong typing for inputs
     - Include proper error handling
     - Revalidate affected cache entries
     - Return structured responses
     - Handle both form submissions and programmatic calls

7. **Database Operations**

   - All Prisma queries must be in dedicated service files under `/lib/services`
   - Use transactions for operations affecting multiple tables
   - Include proper error handling and type checking
   - Example:

   ```typescript:lib/services/product.ts
   import prisma from '@/lib/db'
   import type { Prisma } from '@prisma/client'

   export async function createProduct(data: Prisma.ProductCreateInput) {
     try {
       return await prisma.$transaction(async (tx) => {
         const product = await tx.product.create({
           data,
           include: {
             // Include related data as needed
           }
         })
         return product
       })
     } catch (error) {
       // Log error appropriately
       throw new Error('Failed to create product')
     }
   }
   ```

   - Always use Prisma's generated types
   - Implement proper error handling for database operations
   - Configure automatic database backups through Vercel dashboard
   - Set up database branching for preview deployments
   - Monitor database performance in Vercel Dashboard

8. **Styling**

   - Use Tailwind classes exclusively
   - Follow mobile-first approach
   - Use Shadcn UI components when available
   - Custom styles must be approved by team lead

9. **Performance**

   - Images must use Next.js Image component
   - Implement proper loading states
   - Use React Suspense boundaries
   - Lazy load non-critical components

10. **Testing**

- Write unit tests for utility functions
- Include integration tests for critical paths
- Test admin operations thoroughly
- Ensure proper error states are handled

11. **Environment & Security**
    - Never commit `.env` files
    - Use environment variables for all sensitive data
    - Follow least privilege principle for admin functions
    - Document required env variables in `.env.example`

## Deployment Information

- Project is deployed to locally

## Database Configuration

- Use Prisma with PostgreSQL
- Required environment variables:
  ```
  POSTGRES_PRISMA_URL="postgresql://username:password@host:port/database"    # Uses connection pooling
  POSTGRES_URL_NON_POOLING="postgresql://username:password@host:port/database"  # Uses direct connection
  ```
- Configure database in schema.prisma:
  ```prisma
  datasource db {
    provider = "postgresql"
    url      = env("POSTGRES_PRISMA_URL")      // uses connection pooling
    directUrl = env("POSTGRES_URL_NON_POOLING") // uses a direct connection
  }
  ```
- Follow Prisma's best practices for database access
- Connection pooling is configured automatically through the POSTGRES_PRISMA_URL
- Direct connections are available when needed through POSTGRES_URL_NON_POOLING

### Key Edge Function Considerations:

- Use Edge Runtime in page/route segments requiring edge deployment
- Keep bundle sizes minimal - avoid large dependencies
- Cache aggressively using Next.js built-in caching mechanisms
- Use streaming responses for improved TTFB
- Store session data in edge-compatible storage (e.g., Redis, Upstash)
- Ensure all APIs and database queries are edge-compatible
- Consider regional deployments for data residency requirements

## Consider the Whole Project

- Check existing components in `/components`
- Review service patterns in `/lib/services`
- Consult team lead for architectural decisions
- Use the project's Discord channel for questions

Remember: This is a production application. When in doubt, prioritize maintainability and type safety over clever solutions.

## Route Organization

1. **Route Groups**

   - Use Next.js route groups to separate public and internal sections:
     ```
     app/
       (site)/
         page.tsx           # Public home page
         products/
         blog/
         cart/
       (dashboard)/
         page.tsx           # Admin dashboard
         products/
         orders/
         posts/
     ```

2. **(site) Group Standards**

   - Contains all public-facing store components
   - Required features:
     - Product browsing and search
     - Care tips and blog posts
     - Shopping cart functionality
     - Customer notifications (email/in-app)
     - Order status tracking
   - Must implement responsive design for all customer-facing pages
   - Authentication optional except for cart/checkout

3. **(dashboard) Group Standards**

   - Contains all internal management tools
   - Required features:
     - Product management (CRUD operations)
     - Inventory control
     - Content management (blog posts, care tips)
     - Order processing
   - Must implement Clerk authentication
   - All routes must verify staff role
   - Co-locate management actions with their respective components

4. **Shared Resources**

   - Common components remain in root `/components`
